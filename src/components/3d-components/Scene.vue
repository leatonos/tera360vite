<script setup lang="ts">
import { TresCanvas } from "@tresjs/core";
import { CameraControls, TransformControls } from "@tresjs/cientos";
import { loadAllTextures } from "../../utilis/loadAllTextures";
import { ref, computed, watch, onMounted, type Ref } from "vue";
import * as THREE from "three";
import type { PerspectiveCamera, Mesh } from "three";
import { useTourStore } from "../../piniaStore/store";
import type { CircleInfo } from "../../types";

const store = useTourStore();

// Initial state
const currentSceneBackground = ref<string>("");
const rotationRad = ref((store.$state.tour.scenes[0].rotation || 0) * Math.PI / 180)
const cameraRef = ref<PerspectiveCamera | null>(null);
const allCircles = ref<Array<CircleInfo>>([]);
const currentSceneIndex = ref<number>(0);
const textures = ref<Record<string, THREE.Texture>>({});
const currentTexture = ref(null as THREE.Texture|null);
const loadingTexture = ref(true);
const loadingProgress = ref(0);
const isFading = ref(false)
const cameraSpeed = ref(-0.2)
const isTouch = ref(false);



//canvas element ref
const canvasElement = ref<HTMLElement|null>(null)

function setSceneTexture(url: string) {
  const tex = textures.value[url];
  if (tex) {
    currentTexture.value = tex;
    currentSceneBackground.value = url;
  }
}

//Loads initial texture and Circles
onMounted(async () => {

  const index = store.$state.currentSceneIndex || 0;
  const scene = store.$state.tour.scenes[index];
  loadingTexture.value = true;

  //Creates a list of all backgrounds to preload them
  const allBackgrounds = store.$state.tour.scenes.map(scene => scene.background);
  
  // Preload all textures and tracks loading progress
  const loadAllTexturesResult = await loadAllTextures(allBackgrounds, (percent) => {
    loadingProgress.value = percent;
  });

  textures.value = loadAllTexturesResult;

  // Sets initial texture
  setSceneTexture(scene.background);
  currentSceneIndex.value = index;
  rotationRad.value = (scene.rotation || 0) * Math.PI / 180;
  allCircles.value = scene.circles;
  
  // Finishes loading sequence
  loadingTexture.value = false;

   isTouch.value = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

if(window.innerWidth < 600 || 'ontouchstart' in window || navigator.maxTouchPoints > 0){
  cameraSpeed.value = -0.4
 }

});


//Animated zoom function
async function smoothZoom(cameraRef: Ref<THREE.PerspectiveCamera | null>,targetFov: number, speed:number): Promise<void> {
  return new Promise((resolve) => {
    if (!cameraRef.value) return resolve();
    const cam = cameraRef.value;
    let animationId: number;
    let hasStartedFading = false;

    // Animation loop
    const animate = () => {
      cam.fov += (targetFov - cam.fov) * speed;
      cam.updateProjectionMatrix();

      // Start fading out when close to target FOV
      if(cam.fov/targetFov < 1.9 && !isFading.value && !hasStartedFading){
        isFading.value = true;
        hasStartedFading = true;
      }

      // Continue the animation until the target FOV is reached
      if (Math.abs(cam.fov - targetFov) > 0.2 ) {
        animationId = requestAnimationFrame(animate);
      }else{
        // Ensure the final FOV is set precisely
        cam.fov = targetFov;
        cam.updateProjectionMatrix();
        cancelAnimationFrame(animationId);
        resolve();
      }
    };

    animate();
  });
}

// ---------------------------
// Circle click handler - Scene transition
// ---------------------------
/**
 * 
 * @param circle - CircleInfo of the clicked circle
 */
async function handleCircleClick(circle: CircleInfo) {

  //If the clicked circle is already selected, do nothing (Only for editor mode)
  if (selectedCircleId.value === circle.id) return;

  //Starts loading sequence
  allCircles.value = [];
  // Smooth zoom in
  await smoothZoom(cameraRef, 25, 0.1);

  // Looks for the new scene by circle's onClickAction
  const newIndex = store.$state.tour.scenes.findIndex(scene => scene.id === circle.onClickAction.actionArgs);
  const newScene = store.$state.tour.scenes[newIndex];

  currentSceneIndex.value = newIndex;
  currentSceneBackground.value = newScene.background;
  rotationRad.value = (newScene.rotation || 0) * Math.PI / 180;

  // âœ… change texture
  setSceneTexture(newScene.background);
  allCircles.value = newScene.circles;
  store.setCurrentSceneIndex(newIndex);


  if (cameraRef.value) {
    cameraRef.value.fov = 50;
    cameraRef.value.updateProjectionMatrix();
  }

  setTimeout(() => {
    isFading.value = false;
  }, 100); 
}

// ---------------------------
// Selection / TransformControls
// ---------------------------

// store all meshes by circle ID
const selectedCircleId = computed(() => store.$state.selectedCircle ? store.$state.selectedCircle.id : null);
const selectedMesh = ref<Mesh | null>(null);
const meshRefs: Record<string, Mesh | null> = {};
// watch circle selection
watch(selectedCircleId, (newId) => {
  if (newId && meshRefs[newId]) {
    selectedMesh.value = meshRefs[newId];
    //cameraSpeed.value = 0.2
  }else {
    selectedMesh.value = null;
    //cameraSpeed.value = -0.2
  }
});

//---------------------------
// Handle external scene index changes
//---------------------------
watch(() => store.$state.currentSceneIndex, async (newIndex) => {
  if (newIndex === currentSceneIndex.value) return;

  allCircles.value = [];
  isFading.value = true;

  const newScene = store.$state.tour.scenes[newIndex];
  rotationRad.value = (newScene.rotation || 0) * Math.PI / 180;

  setSceneTexture(newScene.background);

  isFading.value = false;

  allCircles.value = newScene.circles;
  currentSceneIndex.value = newIndex;
});
 
// ---------------------------
// TransformControls change handler
// ---------------------------
function handleTransformChange() {
  if (!selectedMesh.value) return;

  const pos = selectedMesh.value.position;
  const circleId = selectedCircleId.value;

 store.editCircle(
    currentSceneIndex.value,
    store.$state.tour.scenes[currentSceneIndex.value].circles.findIndex(c => c.id === circleId),
    {
      ...store.$state.selectedCircle!,
      coordinates: [pos.x, pos.y, pos.z]
    }
  );
}

// ---------------------------
// Camera updates
// ---------------------------
function updateCamera() {
  if (!cameraRef.value) return;
  const cam = cameraRef.value;
  const pos = cam.position;
  const dir = new THREE.Vector3();
  cam.getWorldDirection(dir);
  store.setCameraPosition({ x: pos.x, y: pos.y, z: pos.z });
  store.setCameraDirection({ x: dir.x, y: dir.y, z: dir.z });
}
</script>

<template>
  
  <div class="canvas-wrapper" ref="canvasElement" :class="{ fadeOut: isFading }">
  <div v-if="loadingTexture" class="loading-screen">
    <p class="loading-txt">Carregando... {{ loadingProgress }}%</p>
  </div>
  <TresCanvas preset="realistic" clearColor="#ffffff" :antialias="true">    
    <TresPerspectiveCamera ref="cameraRef" :position="[0,0,0.5]" :far="2000" :fov="50" />
    <CameraControls 
      @end="updateCamera" 
      :maxDistance="3"
      :azimuthRotateSpeed="cameraSpeed"
      :polarRotateSpeed="cameraSpeed"
      />

    <!-- Skybox -->
    <TresMesh color="#ffffff" :position="[0,0,0]" :scale="6" :rotation="[0,rotationRad,0]">
      <TresSphereGeometry :args="[1,100,100]" />
      <TresMeshBasicMaterial :key="currentSceneBackground" color="#ffffff" :map="currentTexture" :side="2" :toneMapped="false"/>
    </TresMesh>
    
    <!-- Circles -->
    <TresMesh
      v-for="circle in allCircles"
      :key="circle.id"
      :position="circle.coordinates"
      :scale="circle.scale"
      :rotation="[Math.PI/2,0,0]"
      @click="handleCircleClick(circle)"
      @pointerDown="()=>if(isTouch)"
      :ref="el => { if(el) meshRefs[circle.id] = el as unknown as Mesh }"
    >
      <TresCircleGeometry :args="[1,32]" />
      <TresMeshBasicMaterial
        :color="circle.color"
        :side="2"
      />
    </TresMesh>
    <!-- TransformControls attached to selected mesh -->
    <TransformControls
      v-if="selectedMesh"
      :object="selectedMesh"
      @objectChange="handleTransformChange"
      @dragging="()=>{ cameraSpeed = cameraSpeed * -1}"
      mode="translate"
    />
  </TresCanvas>
   </div>
</template>

<style scoped>
  /* scene canvas fadeout animation */
.canvas-wrapper {
  top: 0;
  position: relative;
  width: 100%;
  height: 100%;
  transition: opacity .5s ease;
  opacity: 1;
}

.canvas-wrapper.fadeOut {
  opacity: 0;
}

.loading-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: white;
  opacity: 0.8;
  z-index: 10;
  animation: fadeOutLoading 1s ease forwards 1.5s; /* fade out after 1.5s delay */
} 
.loading-txt{
  color: black;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5em;
}
</style>